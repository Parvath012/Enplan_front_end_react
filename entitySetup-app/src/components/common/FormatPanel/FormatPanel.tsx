import React, { useState, useEffect, Suspense } from 'react';
import { Box, RadioGroup, FormControlLabel, Typography, Button, IconButton } from '@mui/material';
import { Close } from '@carbon/icons-react';
// Module Federation imports
const CustomTooltip = React.lazy(() => import('commonApp/CustomTooltip'));
const CustomRadio = React.lazy(() => import('commonApp/CustomRadio'));
import './FormatPanel.scss';

export interface FormatOption {
value: string;
label: string;
isDefault?: boolean;
}

export interface FormatPanelProps {
isOpen: boolean;
onClose: () => void;
onSave: (format: string, preview: string) => void; // now expects preview too
title: string;
formatOptions: FormatOption[];
currentFormat: string;
previewText: string;
hasAutoGeneratedContent?: boolean;
generatePreview?: (format: string) => string;
}

const FormatPanel: React.FC<FormatPanelProps> = ({
isOpen,
onClose,
onSave,
title,
formatOptions,
currentFormat,
previewText,
hasAutoGeneratedContent = true,
generatePreview,
}) => {
const [selectedFormat, setSelectedFormat] = useState<string>(currentFormat);

// live preview value derived from selectedFormat (or fallback previewText)
const [livePreview, setLivePreview] = useState<string>(
generatePreview ? generatePreview(currentFormat) : previewText
);

// Keep local state in sync when parent changes currentFormat or previewText
useEffect(() => {
setSelectedFormat(currentFormat);
setLivePreview(generatePreview ? generatePreview(currentFormat) : previewText);
}, [currentFormat, previewText, generatePreview]);

// Update live preview when selection changes
useEffect(() => {
if (generatePreview) {
try {
setLivePreview(generatePreview(selectedFormat));
} catch {
setLivePreview(previewText || '');
}
} else {
setLivePreview(previewText || '');
}
}, [selectedFormat, generatePreview, previewText]);

// Save both format and generated preview to parent
const handleSave = () => {
if (hasAutoGeneratedContent) {
const preview = generatePreview ? generatePreview(selectedFormat) : previewText || '';
onSave(selectedFormat, preview);
} else {
onSave(selectedFormat, '');
}
onClose();
};

const handleCancel = () => {
setSelectedFormat(currentFormat);
setLivePreview(generatePreview ? generatePreview(currentFormat) : previewText || '');
onClose();
};

// Blur admin sidebar when panel is open (existing behavior retained)
useEffect(() => {
if (isOpen) {
const sidebarSelectors = [
'[class*="sidebar"]',
'[class*="nav"]',
'[class*="menu"]',
'[class*="drawer"]',
'[class*="aside"]',
'.admin-sidebar',
'.sidebar',
'.navigation',
'.nav-menu',
'.left-panel',
'.side-panel'
];


  sidebarSelectors.forEach((selector) => {
    document.querySelectorAll(selector).forEach((el) => el.classList.add('format-panel-blur'));
  });
} else {
  document.querySelectorAll('.format-panel-blur').forEach((el) => el.classList.remove('format-panel-blur'));
}

return () => {
  document.querySelectorAll('.format-panel-blur').forEach((el) => el.classList.remove('format-panel-blur'));
};


}, [isOpen]);

return (
<>
{isOpen && <Box className="format-panel__backdrop" onClick={handleCancel} />}

  <Box className={`format-panel ${isOpen ? 'format-panel--open' : ''}`}>
    {/* Header */}
    <Box className="format-panel__header">
      <Typography className="format-panel__title">{title}</Typography>
      <Suspense fallback={<div></div>}>
        <CustomTooltip title="Close" placement="bottom" arrow={false} followCursor={true}>
          <IconButton aria-label="Close" onClick={handleCancel} className="format-panel__close-icon">
            <Close size={22} />
          </IconButton>
        </CustomTooltip>
      </Suspense>
    </Box>

    {/* Content */}
    <Box className="format-panel__content">
      <Typography className="format-panel__section-title">
        {title.replace(' Format', ' Naming Formats')}
      </Typography>

      {/* Use RadioGroup for semantics but DO NOT rely on event.target.value (some custom radios don't forward value) */}
      <RadioGroup value={selectedFormat} className="format-panel__radio-group" >
        {formatOptions.map((option) => {
          const isChecked = selectedFormat === option.value;
          return (
            <FormControlLabel
              key={option.value}
              value={option.value}
              control={
                <Suspense fallback={<div />}>
                  {/* Pass checked & onChange explicitly to custom radio so the component renders correctly */}
                  <CustomRadio
                    className="format-panel__radio"
                    checked={isChecked}
                    onChange={() => setSelectedFormat(option.value)}
                  />
                </Suspense>
              }
              label={
                <Box className="format-panel__radio-label">
                  <Typography className="format-panel__radio-text">{option.label}</Typography>
                  {option.isDefault && <Typography className="format-panel__default-text">Default</Typography>}
                </Box>
              }
              className={`format-panel__radio-item ${isChecked ? 'format-panel__radio-item--checked' : ''}`}
              // ensure clicking label updates selection even if custom radio doesn't forward native events
              onClick={() => setSelectedFormat(option.value)}
              onKeyDown={(e: any) => {
                if (e.key === 'Enter' || e.key === ' ') {
                  e.preventDefault();
                  setSelectedFormat(option.value);
                }
              }}
            />
          );
        })}
      </RadioGroup>
    </Box>

    {/* Live Preview */}
    <Box className="format-panel__preview-section">
      <Typography className="format-panel__preview-label">Preview</Typography>
      <Typography className="format-panel__preview-text">{livePreview}</Typography>
    </Box>

    {/* Actions */}
    <Box className="format-panel__actions">
      <Button className="format-panel__cancel-btn" onClick={handleCancel}>Cancel</Button>
      <Button className="format-panel__save-btn" onClick={handleSave}>Save</Button>
    </Box>
  </Box>
</>
);
};

export default FormatPanel;


